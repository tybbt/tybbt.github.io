<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="TYBBT的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="TYBBT的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TYBBT的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>TYBBT的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">TYBBT的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/25/bugList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TYBBT的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/bugList/" itemprop="url">Bug历程汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-25T17:00:13+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>模版：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Q: 问题</span></span><br><span class="line">Date：日期</span><br><span class="line">Detail：细节描述</span><br><span class="line">Proj：工程</span><br><span class="line">A：原因</span><br></pre></td></tr></table></figure></p>
<h3 id="Q-关于转场动画animationBlock执行Bug"><a href="#Q-关于转场动画animationBlock执行Bug" class="headerlink" title="Q: 关于转场动画animationBlock执行Bug"></a>Q: 关于转场动画animationBlock执行Bug</h3><p>Date：2018-10-25<br>Detail：在转场动画中使用animationwithDuration：animate：complete：时animate块执行了，但无动画效果，complete块未执行。此时导致toView（或fromView）保持动画前状态，complete永远不执行。<br>Proj：Demo/项目预热/UIDemo<br>A：转场动画主要分为动画控制器与交互控制器，本bug由于两者全部添加，但交互控制器未实现，此时交互代理中返回这个没有具体实现的控制器，导致执行过程出现问题，从而导致动画不能结束，而动画过程也无法执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/07/dispatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TYBBT的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/07/dispatch/" itemprop="url">dispatch 多线程操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-07T15:56:34+08:00">
                2018-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在基本的dispatch掌握情况下看以下信息</p>
<h2 id="dispatch-情况分析"><a href="#dispatch-情况分析" class="headerlink" title="dispatch 情况分析"></a>dispatch 情况分析</h2><p>什么时候会启动新线程：在非主线程中创建一个异步任务，<br>在串行队列上创建异步任务开启‘一条’新线程，<br>在并行队列上创建异步任务会开启多条线程，任务被分配到各个线程中<br>⚠️注意：创建dispatch_queue并不是创建线程，只是创建队列，该含义是大中枢派发，由队列判断是否需要开启新线程，需要        开启时才会创建新的线程并由队列将任务添加到某个线程中。</p>
<h3 id="一、串行同步"><a href="#一、串行同步" class="headerlink" title="一、串行同步"></a>一、串行同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">serialQueue.sync&#123; //创建同步任务，不会开启新线程，某人在当前所在上下文线程中执行</span><br><span class="line">    <span class="built_in">print</span>(1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(2)         //在当前所在线程中执行</span><br><span class="line">serialQueue.sync&#123;</span><br><span class="line">    <span class="built_in">print</span>(3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(4);</span><br></pre></td></tr></table></figure>
<p>可以看到所有的任务都是在同一条线程中执行，所以执行的顺序是固定的。相当于没写sync</p>
<h3 id="二、串行异步"><a href="#二、串行异步" class="headerlink" title="二、串行异步"></a>二、串行异步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">serialQueue.async&#123; //异步任务会开启新线程</span><br><span class="line">    <span class="built_in">print</span>(1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(2)     //在当前线程中执行</span><br><span class="line">serialQueue.async&#123;  //串行队列只开启一条线程，该任务也被添加到上面的新线程中</span><br><span class="line">    <span class="built_in">print</span>(3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(4)</span><br></pre></td></tr></table></figure>
<p>由于新建了一条线程，相当于另一条世界线，两个线程相互独立，但在各自线程中保持有序，首先说由于都是串行，所以1一定先于3，2一定先于4，但还有一个要注意的就是2和3的顺序，从添加顺序看，1执行的时间取决于多方面，线程创建时间，添加任务的耗时等等，所以1和2的顺序不固定，但在添加完1后，顺序是执行完2后才会添加3，所以还要注意2一定比3先输出，3的情况同1，可能立即执行，也可能由于某种原因耗时，所以与4随机排布</p>
<h3 id="三、串行异步-套-同步"><a href="#三、串行异步-套-同步" class="headerlink" title="三、串行异步 套 同步"></a>三、串行异步 套 同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(1)</span><br><span class="line">serialQueue.async&#123;  //异步任务，独立在新线程中完成</span><br><span class="line">    <span class="built_in">print</span>(2)        //执行，</span><br><span class="line">    serialQueue.sync&#123;</span><br><span class="line">        <span class="built_in">print</span>(3)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(4)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(5)    //当前线程执行</span><br></pre></td></tr></table></figure>
<p>在添加1后，开启一条新线程执行异步任务，在新线程中，先执行2，接下来执行一个同步任务3，不会开启新线程而是将任务添加到当前线程中作为下一个任务，但执行到这里由于是一个同步任务，所以会阻塞当前线程等待执行结果，需要先等待3任务结束才能执行下一个任务，可3是当前队列的下一个任务，而且需要等待上一个任务完成才会执行，导致互相等待，产生死锁，但5任务是在另一个线程中没有影响依旧会执行切顺序可以在2的前后</p>
<h3 id="四、串行同步-套-异步"><a href="#四、串行同步-套-异步" class="headerlink" title="四、串行同步 套 异步"></a>四、串行同步 套 异步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(1)</span><br><span class="line">seialQueue.sync&#123;</span><br><span class="line">    <span class="built_in">print</span>(2)</span><br><span class="line">    serialQueue.async&#123;</span><br><span class="line">        <span class="built_in">print</span>(3)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(4)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(5)</span><br></pre></td></tr></table></figure>
<p>江湖规矩先执行1，任务为同步任务，所以不开启新线程，此时会执行2，接着是任务3一个异步任务，开启新线程，异步任务不需等待结果，顺序执行下面的4，5.任务3在添加完成后的任意时间都有可能完成。</p>
<h3 id="五、并行同步"><a href="#五、并行同步" class="headerlink" title="五、并行同步"></a>五、并行同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">concurrentQueue.sync&#123;</span><br><span class="line">    <span class="built_in">print</span>(1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(2)</span><br><span class="line">concurrentQueue.sync&#123;</span><br><span class="line">    <span class="built_in">print</span>(3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(4)</span><br></pre></td></tr></table></figure>
<p>和串行队列是一样，由于不属于开启新线程条件，所以都是在当前线程中顺序执行。</p>
<h3 id="六、并行异步"><a href="#六、并行异步" class="headerlink" title="六、并行异步"></a>六、并行异步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">concurrentQueue.async&#123;</span><br><span class="line">    <span class="built_in">print</span>(1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(2)</span><br><span class="line">concurrentQueue.async&#123;</span><br><span class="line">    <span class="built_in">print</span>(3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(4)</span><br></pre></td></tr></table></figure>
<p>可以确定的只有2一定比3和4先执行，其他完全随机乱序</p>
<h3 id="七、并行异步-套-同步"><a href="#七、并行异步-套-同步" class="headerlink" title="七、并行异步 套 同步"></a>七、并行异步 套 同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(1)</span><br><span class="line">concurrentQueue.async&#123;</span><br><span class="line">    <span class="built_in">print</span>(2)</span><br><span class="line">    concurrentQueue.sync&#123;</span><br><span class="line">        <span class="built_in">print</span>(3)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(4)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(5)</span><br></pre></td></tr></table></figure>
<p>1打头，异步任务创建新线程，可能先2，也可能先5，异步任务中的同步任务不会创建新线程所以顺序执行2，3，4，而5在1后面随机插入，</p>
<h3 id="八、并行同步-套-异步"><a href="#八、并行同步-套-异步" class="headerlink" title="八、并行同步 套 异步"></a>八、并行同步 套 异步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(1)</span><br><span class="line">concurrentQueue.sync&#123;</span><br><span class="line">    <span class="built_in">print</span>(2)</span><br><span class="line">    concurrentQueue.async&#123;</span><br><span class="line">        <span class="built_in">print</span>(3)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(4)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(5)</span><br></pre></td></tr></table></figure>
<p>1打头，同步任务不创建新线程，顺序执行2，3任务为异步任务，创建新线程，在4，5顺序排布下，3在2后随机插入。</p>
<h3 id="九、并行异步-套-异步"><a href="#九、并行异步-套-异步" class="headerlink" title="九、并行异步 套 异步"></a>九、并行异步 套 异步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">这种情况单说的原因在于其完全随机性，</span><br><span class="line">dispatch_async(dq_concurrent, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"1,%@"</span>,[NSThread currentThread]);</span><br><span class="line">    dispatch_async(dq_concurrent, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"1.1,%@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dq_concurrent, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"2.1,%@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dq_concurrent, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"2.5,%@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dq_concurrent, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"2.6,%@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dq_concurrent, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"2.7,%@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面这种情况下，多次试验，出现的实验结果完全随机，而且线程的创建也是完全靠队列来分配，我们所说的见到异步创建线程的方法也不适用，实际上是见到异步弱无可用线程就会开启新线程。所以这里的线程数和执行顺序完全随机。</p>
<h3 id="⚠️绝对不能做的事"><a href="#⚠️绝对不能做的事" class="headerlink" title="⚠️绝对不能做的事"></a>⚠️绝对不能做的事</h3><p>无论在什么位置<br>dispatch_sync(dispatch_get_main_queue(),block);<br>绝对不能发生，100%死锁<br>主队列为串行队列，无论何时使用这个，无论在哪个线程使用这个，都会给主线程添加一个同步任务，该代码块会等待内部任务完成并阻塞主线程，而此时该代码块中的任务在已经被阻塞的主线程中永远无法执行。</p>
<h2 id="Dispatch-group"><a href="#Dispatch-group" class="headerlink" title="Dispatch_group"></a>Dispatch_group</h2><p>dispatch_group_t用于创建一个group，group用于整合任务，我们需要在某些任务结束后利用数据执行些整合任务，此时使用group，其实用简单易懂的写法来说更容易理解<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group&#123;</span><br><span class="line">dispatch_async(serialQueue/concurrentQueue,^&#123;&#125;)</span><br><span class="line">dispatch_async(serialQueue/concurrentQueue,^&#123;&#125;)</span><br><span class="line">&#125; completion: ^&#123;</span><br><span class="line">//Done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种写法更容易理解，但是当然不能这么用,应该像下面这样建立<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(group,serialQueue/concurrentQueue, ^&#123; block&#125;);</span><br><span class="line">dispatch_group_async(group,serialQueue/concurrentQueue, ^&#123; block&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="接受完成信号的方式有两种"><a href="#接受完成信号的方式有两种" class="headerlink" title="接受完成信号的方式有两种"></a>接受完成信号的方式有两种</h3><p>1、dispatch_group_notify(group, queue,^{//Done});<br>    该方法会受到组执行全部结束，收到通知并触发block，类似于observervlueforkey的触发方式<br>2、dispatch_group_wait(group,DISPATCH_TIME_FOREVER);<br>    该方法会阻塞当前线程并等待组任务全部执行结束，在继续执行，由于会阻塞线程所以不推荐使用</p>
<h3 id="同步执行与异步执行"><a href="#同步执行与异步执行" class="headerlink" title="同步执行与异步执行"></a>同步执行与异步执行</h3><p>实际上dispatch_group_async（）方法会在一个新线程执行任务，但相当于一个新主线程，也是串行的。所以同样也有时需要有同步执行与异步执行，但要注意 dispatch_group_async() 与 dispatch_async()不能嵌套使用，notify方法是在结束后收到通知出发，若在group_async中使用async，async会开启新线程，当前任务视作直接返回，所以算是完成任务，此时如果都是这种，notify会在实际并未执行完任务的情况下触发。<br>此时应该使用另一种 dispatch_group_enter(group)\ dispatch_group_leave(group) ,该方法是用范围来指定group<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_enter(group)</span><br><span class="line">dispatch_async(queue,^&#123;</span><br><span class="line">    dispatch_group_leave(group)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>enter与leave之间的视作添加进group，此时notify会一直追踪group，当group中无任务时便会触发notify，并且可以看到aysnc任务没结束前group中任务不算结束。</p>
<h2 id="Dispatch-barrier"><a href="#Dispatch-barrier" class="headerlink" title="Dispatch_barrier"></a>Dispatch_barrier</h2><p>栅栏代码块，也是一种处理任务处理次序的方式，barrier块前的任务会先执行，然后此时会遇到barrier，barrier其实不是太关心队列的同步异步，而是比加关注自己的同步异步</p>
<ul>
<li>dispatch_barrier_sync属于完全阻隔，类似于在这停顿，和wait效果类似，等到前面全部完成，此时在单独执行barrierBlock，等到结束以后，在执行后面的</li>
<li>dispatch_barrier_async属于不完全阻隔，类似于将barrier添加到了队列中而不是放置在当前位置，会将队列中的人物分割，但所有不属于该队列的人物则不会收到barrier限制，类似一个过滤器，所有满足条件的（属于这个队列）都会被挡住，执行完自己的任务才会继续向下，但其他的队列可以顺畅通行。<br>两种barrier有一个共同的特性就是，barrier一定是被单独执行。</li>
</ul>
<h2 id="多线程同步任务串行执行"><a href="#多线程同步任务串行执行" class="headerlink" title="多线程同步任务串行执行"></a>多线程同步任务串行执行</h2><p>有一种情况，有一个计算分为三部分，第二部分依赖于第一部分，第三部分依赖于前两个部分，此时的状况就是任务分为三部分在不同的线程上并行，但要是需要顺序的情况下多线程串行的话呢，此时就需要设置三个线程的优先级相同，那么任务就会按添加顺序依次执行了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_set_target_queue(dq_serial_one, dq_serial_target);</span><br><span class="line">dispatch_set_target_queue(dq_serial_two, dq_serial_target);</span><br><span class="line">dispatch_set_target_queue(dq_serial_three, dq_serial_target);</span><br></pre></td></tr></table></figure></p>
<p>当然此时用NSOperation操作更加便利。</p>
<h2 id="线程安全的信号量"><a href="#线程安全的信号量" class="headerlink" title="线程安全的信号量"></a>线程安全的信号量</h2><h3 id="dispatch-semaphore-t"><a href="#dispatch-semaphore-t" class="headerlink" title="dispatch_semaphore_t"></a>dispatch_semaphore_t</h3><p>如何保证线程安全是在处理数据时我们经常该考虑的事情，为了防止数据被各个线程竞争导致不可控的结果，我们需要做处理，就是使用锁的机制。dispatch_semaphore是dispatch中提供给我们的信号量<br>在使用时，只需要创建信号量 dispatch_semaphore_create（Int times）就可以了，我们通过dispatch_semaphore_wait进行等待任务，此举会使信号量的times自减，在结束任务时使用signal可以自增以表示任务完成。<br>信号量很好用但也要熟悉其他的锁</p>
<h3 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h3><p>NSLock也是一种很常用的锁,使用起来也是最简单的一种，先获取一个实例变量lock，之后在使用的时候lock 与 unlock就够了，但还有一点就是需要注意，一般在lock前我们还需要一步trylock，因为如果有同时多个调用同时lock会出错，此时锁已经被上锁但想二次上锁所以会出问题，所以先进行一步判断，当确认上一个任务完成可以开始在关上自己的锁防止其他人占用。</p>
<h3 id="NScondition"><a href="#NScondition" class="headerlink" title="NScondition"></a>NScondition</h3><p>类似于lock+semaphore，其使用也可以为方法上锁，还可以通过信号量进行数据同步<br>使用[condition lock]与[condition unlock]进行上锁和解锁<br>使用[condition wait] 与 [condition signal]进行同步<br>需要注意的是同步操作需要在锁域内部实现。<br>即：lock{ signal }unlock   \   lock{ wait }unlock</p>
<h3 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h3><p>递归锁，我们上面遇到一种情况就是lock使用前要trylock的问题，其根源在于一把锁不能被多次持有，所以遇到递归调用内部情况时会导致死锁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun add5 (int x)-&gt; int&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;100) <span class="built_in">return</span> x;</span><br><span class="line">    [lock lock]</span><br><span class="line">    <span class="keyword">for</span>（int  i=0;i&lt;5;i++）&#123;</span><br><span class="line">        x+=add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    [lock unlock];</span><br><span class="line">    <span class="built_in">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在进行递归调用时，lock会出现多次被锁的情况，即使使用trylock也会等待无法继续执行导致死锁。所以才会出现递归锁，递归锁会防止外部介入而在内部递归上锁并递归解锁的方式解决需要递归调用时上锁的状况</p>
<h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p>自旋锁，貌似已经凉了，有大bug</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/29/NStimerMemoryLeak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TYBBT的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/29/NStimerMemoryLeak/" itemprop="url">CADisplayLink内存泄漏问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-29T11:38:38+08:00">
                2018-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么导致的内存泄漏？"><a href="#什么导致的内存泄漏？" class="headerlink" title="什么导致的内存泄漏？"></a>什么导致的内存泄漏？</h2><p>NSTimer、DisplayLink 都是一种系统的定时器，先看看怎么使用</p>
<h3 id="CADisplayLink-amp-NSTimer"><a href="#CADisplayLink-amp-NSTimer" class="headerlink" title="CADisplayLink &amp; NSTimer"></a>CADisplayLink &amp; NSTimer</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSTimer * timer;</span><br><span class="line">@property (nonatomic, strong) CADisplayLink * displayLink;</span><br><span class="line"></span><br><span class="line">- (void)makeTimer</span><br><span class="line">&#123;</span><br><span class="line">_timer = [NSTimer timerWithTimeInterval:3 target:self selector:@selector(refresh) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)makeDisplayLink</span><br><span class="line">&#123;</span><br><span class="line">_displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(refresh)];</span><br><span class="line">[_displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@<span class="string">"dealloc"</span>);</span><br><span class="line">[_timer invalidate];</span><br><span class="line">[_displayLink invalidate];</span><br><span class="line">_timer = nil;</span><br><span class="line">_displayLink = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的使用一下定时器，这是在程序中基本中的基本，但此时，如果我们做一个pushpop操作，那么就会发现，dealloc方法中的释放全部未执行，也可以看一下debug面板中CPU的占用率发现持续升高，每做一次pushpop操作就会导致一份timer内存的泄漏。</p>
<h3 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h3><p>在使用Memory Graph查看后可以发现，我们push了几次，就会出现几个包含了Timer的控制器，而其原因就是Runloop引用了NStimer，而timer引用着控制器，导致控制器无法释放，控制器无法释放就导致了不能执行timer的invalidate方法不能释放timer，这样就导致了timer与controller之间的循环引用，从而导致内存泄漏。同理displaylink也同样。<br>同样也可以从代码看出两者的初始化方法都使用self作为target，而在计时器内部self会被持有，但self也持有了timer。</p>
<h3 id="NSTimer优化"><a href="#NSTimer优化" class="headerlink" title="NSTimer优化"></a>NSTimer优化</h3><p>苹果还是苹果，发现了问题还是会给出补救措施的，使用上述的方法创建的Timer确实会导致内存泄漏，但是，我们可以使用新的方法获得定时器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_timer = [NSTimer timerWithTimeInterval:3 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">            NSLog(@<span class="string">"logTime"</span>);</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure></p>
<p>此时，我们在使用MemGraph查看一下可以发现，在pop后便不会再出现第二个控制器，dealloc方法被执行。</p>
<h3 id="CADisplayLink优化"><a href="#CADisplayLink优化" class="headerlink" title="CADisplayLink优化"></a>CADisplayLink优化</h3><p>CADisplayLink在我们查看API后发现并无这种“高能”方法，所以我们只能自己想办法。想要解决内存泄漏，就是要解决循环引用，要打破循环引用说起来也简单，我们可以利用“中间人”来进行防治循环引用。<br>这种方法来自于YYKit中的YYFPSLabel，将使用NSProxy来解决。<br>NSProxy这个类是一个抽象基类，详细的可以自己去找找，该类最主要的两个方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation;</span><br><span class="line">- (nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure></p>
<p>通过这两个转发消息的方法，我们可以制作一个中间人，由中间人将关系弱化，并将信息在两者之间传递。首先，我们创建一个NSProxy的子类-WeakProxy，我们为该类添加一个target用作消息的接受者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface WeakProxy : NSProxy</span><br><span class="line">@property (nonatomic, weak, <span class="built_in">readonly</span>) id target;</span><br><span class="line">+ (instancetype)proxyWithTarget: (id)target;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>接下来是内部实现，我们通过将WeakProxy方法所接收到的消息，传递给target。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)proxyWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> [[WeakProxy alloc] initWithTarget:target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithTarget: (id)target</span><br><span class="line">&#123;</span><br><span class="line">    _target = target;</span><br><span class="line">    <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> [_target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ([_target respondsToSelector:[invocation selector]]) &#123;</span><br><span class="line">    [invocation invokeWithTarget:_target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然有了WeakProxy我们便知道了要如何解决循环引用了，我们将self设为target，并使用weak形式持有self。<br>此时在使用Displaylink初始化方法时，我们使用WeakProxy作为displaylink的持有对象，现在互相持有的是displaylink与weakProxy，而proxy弱引用了target。当self被释放时，只有一个弱引用所以可以成功释放。而释放后便可以执行dealloc方法，在方法中无效化了displaylink，displaylink释放从而释放proxy，打破了循环引用解决了内存泄漏。</p>
<p>更多参考：<br>WeakProxy：  <a href="https://www.jianshu.com/p/8adb7f8dec82" target="_blank" rel="noopener">https://www.jianshu.com/p/8adb7f8dec82</a><br>Memory Graph：<a href="https://www.jianshu.com/p/7fec49cc2a03" target="_blank" rel="noopener">https://www.jianshu.com/p/7fec49cc2a03</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/UIColectionView-point/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TYBBT的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/UIColectionView-point/" itemprop="url">UIColectionView 知识点，从使用到丰富</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-10T14:08:32+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>UICollectionView作为两大集合视图之一，在应用程序中至关重要，再学会简单的使用后还需要学会定制属于我们的cell，展示出更多样的集合。</p>
<h2 id="一、使用UICollectionView"><a href="#一、使用UICollectionView" class="headerlink" title="一、使用UICollectionView"></a>一、使用UICollectionView</h2><p>使用CollectionView可以从两种方式引入，首先最为简单的，便是直接创建UICollectionViewController，直接创建的方式获得的是一个继承字UICollectionViewController的子类，UICollectionViewController自己便继承了UICollectionViewDelegate以及UICollectionViewDataSource两个协议，不需要再去做集成，直接实现其中的方法就可以了。<br>CollectionView作为一个集合视图，其展示的元素包含两个部分，UICollectionViewCell以及UICollectionViewLayout，cell适用于展示单个元素，layout是对cell在集合视图内部的布局做处理</p>
<ol>
<li>UIColletionViewCell<br>UICollectionViewCell，与tableviewcell相似，在苹果中，这种大范围使用的 cell都使用了重用机制，点入其定义可以看到，它继承自UICollectionReusableView，而其中则是包含了- prepareForReuse 这个方法，与Tableviewcell不同的是，collectioncell并没有提供给我们默认的视图，不能直接设置title、image之类的，由于collection大部分时候用与显示的都是比较复杂的、不只包含一个视图的多视图结构，所以并没有默认选项，我们可以只是单纯的现设个背景颜色进行区分<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    //提供一个数据源对象</span><br><span class="line">    @property (strong) NSArray * <span class="built_in">source</span>;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //使用数据源为单元格提供不同的色彩</span><br><span class="line">    self.source = @[@<span class="string">"CCF6A4"</span>,@<span class="string">"CE7725"</span>,@<span class="string">"AD456E"</span>,@<span class="string">"FFC4A5"</span>,@<span class="string">"A6CCB3"</span>,@<span class="string">"AFCADC"</span>];</span><br><span class="line">    </span><br><span class="line">    //为集合视图注册item用于重用机制，在复用时会通过CellIdentifier查找是否有能重用的单元。</span><br><span class="line">    [self.collectionView registerClass:[UICollectionViewCell class]         forCellWithReuseIdentifier:@<span class="string">"cell"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView &#123;</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> self.source.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:reuseIdentifier forIndexPath:indexPath];</span><br><span class="line"></span><br><span class="line">    //处理每个单元格的数据，IndexPath代表着单元格在视图中的具体位置下标，如1-3为section1中的第3个位置的单元格（从0开始）</span><br><span class="line">    cell.backgroundColor = [UIColor colorWithRGB: self.source[indexPath.item] ];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此处便创建了一个表格视图,但这是不够的，因为collectionview并不像tableview一样，collectionview的布局是由collectionviewlayout进行处理的，所以，可以在self.collectionViewLayout中处理相关的布局信息。</p>
<ol>
<li>UICollectionViewLayout<br>Layout作为管理布局的中枢，在collectionView中起着至关重要的作用，在collectionViewLayout中我们可以做很多方面的东西，不仅仅是布局，如果我们想在CollectionView中添加header或footerview，都需要在collectionView中添加额外视图以达到目的。<br>在做自己的布局前，先要了解几个重要的方法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)prepareLayout;</span><br><span class="line"></span><br><span class="line">- (nullable NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect;</span><br><span class="line"></span><br><span class="line">- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>第一个方法从名字中可以看出，为布局做准备工作，在布局前，我们先要想好，布局要如何布，为此需要哪些标志位，为此需要对数据作何处理，在布局前我们要让视图做一种什么样的前置状态，这些处理都要在该方法中完成。<br>第二个方法用于提供在视图区域内所有单元的详细布局，何谓详细布局，就是每个位置的单元在整个集合视图上的位置，如果自定义一个布局，所有的位置计算都要有自己进行，不过这里可不是进行最终计算的位置，该方法返回的是一个数组，数组中便是所有位置的布局信息，但真正的计算，是在下面。<br>第三个方法，也就是我一般写真正计算的方法。方法二可以通过调用该方法获取不同位置的布局信息并添加至数组中返回，这个方法不是必要的，你可以将所有的计算移到方法二中，不过这看起来很杂乱无章。</p>
<p>在了解了上述这些后，我们可以进行自己布局了，同样的，也可以更好的用系统提供的一个常规的非常实用的流布局UICollecitonViewFlowLayout。</p>
<ol>
<li>UICollectionViewFlowLayout<br>流布局是系统提供给我们的一个非常好用的布局方式，你只需要提供一些基本信息，就能让你的单元格以流的方式显示在视图上。当你了解上面的几个方法是再去看，很容易明白如何使用，此处不再赘述。</li>
</ol>
<h2 id="二、丰富我的CollectionView"><a href="#二、丰富我的CollectionView" class="headerlink" title="二、丰富我的CollectionView"></a>二、丰富我的CollectionView</h2><p>了解了以上功能后，就可以实现大部分的所需collectionview，但这还远远达不到我们所需要的‘定制’级别的程度，所谓定制，即使需要能实现更加酷炫的效果，而我们现在，可以说只是做到了展示大量数据时使用了除tableview之外的另一种方法而已。<br>在丰富我们的collection时，我们就按现在的样子，向上添加就够了，在添加前，我们先需要了解，我们能添加什么进去，在collectionview中，我们除了基本的视图外，还有两种视图，一种是装饰视图（DecorationView），一种是附加视图（SupplementaryView），装饰视图大部分情况下没那么实用，但还是要说的，那么装饰视图能用来做什么呢？装饰视图便是我们正常collection后面的背景图片，例如可以给我们的collection添加一个暑假的背景看起来像是把cell放到书架上一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UICollectionViewLayoutAttributes *)layoutAttributesForDecorationViewOfKind:(NSString*)decorationViewKind atIndexPath:(NSIndexPath *)indexPath</span><br></pre></td></tr></table></figure></p>
<p>方法是UICollectionViewLayout中的，用于做装饰视图在视图中的布局。</p>
<p>除了装饰视图，实际在大部分情况下，我们用到的都是附加视图，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure></p>
<p>第一个方法出自UICollectionViewDataSource，该方法用于向视图提供附加视图，在使用前先需要注册对应的view<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN NSString *const UICollectionElementKindSectionHeader NS_AVAILABLE_IOS(6_0);</span><br><span class="line">UIKIT_EXTERN NSString *const UICollectionElementKindSectionFooter NS_AVAILABLE_IOS(6_0);</span><br><span class="line"></span><br><span class="line">    [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@<span class="string">"CCC"</span>];</span><br><span class="line">    </span><br><span class="line">    [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@<span class="string">"CCC"</span>];</span><br></pre></td></tr></table></figure></p>
<p>两个视图分别用于提供头视图和尾视图，两个视图都属于附加视图，注册完后便可以在viewForSupplementaryElementOfKind中使用，可以根据indexpath 中的section来获取当前section并未不同的section提供不同的装饰视图，如果我们需要对装饰视图做更多变化的话，还可以使用第二个方法在UICollectionViewlayout中重载layoutAttributesForSupplementaryViewOfKind方法来改变对应section的附加视图布局。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/27/Objc-runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TYBBT的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/Objc-runtime/" itemprop="url">关于runtime中常用方法的一些使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-27T14:39:16+08:00">
                2018-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h2><p>runtime,即是指运行时，我们知道在程序”跑“的过程分为两个阶段，一个是编译时，一个是运行时，编译时即是指在编译时编译器会对代码上一些明面上的错误进行分析报错，如常见的拼写错误，对象不匹配，语法错误等等，还有一些错误是在编译期无法进行判断的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray * arr = [NSMutableArray array];</span><br></pre></td></tr></table></figure></p>
<p>上述这种写法是对是错，能通过编译吗？Cmd+B后发现没有错误，但这种写法意味着什么，在使用arr时我们使用的是一个可变数组还是不可变数组呢？关于数组的内部我们不详细说明，建议在深入之前了解一下_NSArrayM以及_NSArrayI相关的概念你就会理解这方面了。所以这里不谈细节只看表面的话能明显看到arr虽然初始化的是可变数组，但实际上在编写代码时可以看到我们并不能调用可变数组的相关方法如addObject：，这是因为在编译期他被声明为一个不可变数组，是的，编译期。实际在运行时，arr是作为一个可变数组存在的，那么，我们就可以用一些黑科技向其中添加对象。<br>这个黑科技就是runtime，在使用runtime时要注意先要做相关设置，如果想直接使用系统的runtime相关方法，首先要引入相关包才能操作。</p>
<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import &lt;objc/message.h&gt;</span></span><br></pre></td></tr></table></figure>
<p>引入包后还要在Build Settings -&gt; Enable Strict Checking of objc_msgSend Calls -&gt; NO以使用。<br>此时我们便可以通过运行时向arr发送可变数组消息了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(self.data, addAction, item);</span><br></pre></td></tr></table></figure></p>
<p>msgSend是runtime的最基础API，OC是一种动态性语言，不是使用消息调用的方式，而是使用发送消息的当时，类似于函数调用，通过向对象发送消息来使用方法，这也是动态性的原因，你可以不实现向对象发送的方法，编译期是不会有错的，但在运行时会在对象接收到消息时，检查相应的方法列表，如果没有，会依次向上进行消息转发，如果一直到meta类仍没有该消息的实现，此时便会抛出错误，即我们常见的 unrecoginze selector send to class。</p>
<h3 id="objc-setAssociatedObject、objc-getAssociatedObject"><a href="#objc-setAssociatedObject、objc-getAssociatedObject" class="headerlink" title="objc_setAssociatedObject、objc_getAssociatedObject"></a>objc_setAssociatedObject、objc_getAssociatedObject</h3><p>关联对象是一种很常用的并且很方便的东西。category的好处很多，可以让我们避免创建没有必要的类来实现功能的扩展，但catogory很不方便的一点就是我们不能添加新的实例变量。category可以添加的只有新的方法以及–属性property。<br>从不能添加实例变量这一点哦们就可以看出，property对应的synchronize过程已经不能使用了，我们只能自己重写setter、getter方法进行属性的获取及赋值。先来仔细看一下这两个函数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)</span><br><span class="line">objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,</span><br><span class="line">id _Nullable value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure></p>
<p>首先看两个方法共有的参数 objec以及key，object是本对象，即当前我们需要将变量与之绑定的类，一般是self。接下来的key是为该变量增加一个路径path用于获取该属性，有种KVC的意思。接下来是setAssociate中的value，很简单就是我们要绑定的值，做后的policy是存储策略。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.</span><br><span class="line">*   The association is not made atomically. */</span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.</span><br><span class="line">*   The association is not made atomically. */</span><br><span class="line">OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</span><br><span class="line">*   The association is made atomically. */</span><br><span class="line">OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</span><br><span class="line">*   The association is made atomically. */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>相信用过属性关键字的应该都清楚吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/15/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TYBBT的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/15/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-15T11:26:37+08:00">
                2018-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
